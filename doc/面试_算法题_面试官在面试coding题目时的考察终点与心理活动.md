## 本人简介

- 曾经微软dev35 + 10年经验.
- 有FLG offer
去年加入一个startup公司, 最近前景不明，在犹豫要不要去个稳定点的大公司。

我从sde开始面试其他人到现在，估计面试过100+人次的面试和debrief。
我面过
- coding 
- problem solving 
- design 
- behavior
本帖子只谈论纯粹coding视情况讨论要不要再开帖子讨论其他

## 面试开始

方面本文涉及下面几个问题：
1）我刷过这个题目还要不要伪装
2）我觉得这题很简单但是不知道为什么就挂了
3）我觉得面试官不是很友好没提示
4）我一定要bugfree才能被录取吗
5）leetcode的hard问题真的会被问到吗？考起来有什么意义？

我们从一个非常经典的，大家可能都刷过的题目开始。
序列化／反序列化二叉树。

先说个背景，能面到我这里的，基本需要面试者有3-5年的面试经验。
做为应聘，任何微软或者flg的高级dev(63 and aboveT4 / E4 and above)面试官其实都是假设你刷过不少题目的。

我假设你刷过这个题目，所以我并不关心你写的到底有多快，写的是不是完全bugfree，我更关心的是你做事的方式和沟通问题的能力。

具体请看下面

### 1. 提出问题，请序列化／反序列化二叉树什么？

面试者不知道什么是序列化反序列化？
那我就问个多线程爬虫，timing LRU一类的。
如果多线程锁也不会，那说明这个面试者的项目经验很不足。
为了和其他有经验的人相match，往往我会给一个很open的问题或者一个很难的hard coding(取决于他已经被考察了哪个方面)

我个人觉得，很少有面试官上来会考你very hard coding question。
只是当某个面试者与其他面试人比，显得相当缺少项目经验，那他除非能在聪明、敏捷或者下苦功方面，有突出表现，否则很难击败其他候选人。

### 2. 交流阶段

如果面试者马上开始写程序或者马上给出他的想法，我会觉得面试者太过于着急了。

在实际项目中，你很熟悉的地方，可能成为项目中的滑铁卢。
因为你熟悉的地方可能有变化，可能有个big change，你不知道。
可能很快你熟悉的api就不工作了，你总是要有很好的沟通能力确保大家知道，你在做什么，及早的发现你的错误。
在codereview，甚至是test阶段被人发现问题，对项目来说就是个灾难。

我期望面试者能够在这个阶段，提出一些问题。
例如
- 有什么限制条件吗？
- 二叉树的value是什么类型？
- 这个api谁来使用，内部的还是public的？
- 这个api更注重speed，还是space?
- 我需要多线程吗？

如果面试者没问任何问题，马上开始照着leetcode的signature开始coding，甚至class名字也叫solution(很多人），我会觉得面试者做事的方式不够成熟，可能以后工作中会很毛躁需要人来指导。

### 3. 无论你提出的建议是什么

例如你说，你觉得speed更重要，我可能会说我更期待space。
这样做是避免陷入你最熟悉的套路。
假设我说我更需要序列化之后的空间占用最小，这时候，一般的候选人不会刷到这么深，开始思考。
如果候选人根本没有办法优化空间，那我会认为他give up too early。

我希望候选人能安静的思考，提出几种方案，哪怕方案不成立。
如果候选人提出过多的方案，没有问help，这些方案也不工作我，就认为候选人沟通有问题，无法把握好度。

举个leetcode的例子来说明问题的深入，leetcode的序列化格式中''是必要的吗？
\‘\[\’是必要的吗？
有没有办法用byte直接序列化？
byte还能变长吗？
base64是什么？
zip会有帮助吗？

### 4. 候选人选定方案后, 我希望他能和我沟通看看，是不是在有限时间内能够写完

项目中很多时候，谁都知道
- 什么design是正确的，
- 什么是bad smell

最聪明的人不是能做出最好design的，而是在有限时间内能给出大家都能接受的solution的人。
如果空间优化非常好，但是代码将超级复杂，无法写完。
那么面试者应该及时和我交流，我也会偶尔提醒一下，这样能不能在40分钟内写完。
如果面试者坚持，我不会坚持。我会看他是不是能写完，这就是either strong hire or fail。

### 5. 候选人可能这时候说太复杂了
我们简化一下，简化到他熟悉的刷过的coding

### 6. coding开始

到这一步，如果你做了2345中的大部分，并且code看起来
- 似乎是work的
- 没有什么致命的问题

我不会纠结于，比如
- 正负数
- null pointer
- int min 
- coding是不是整洁
一类的无聊问题。
一般就开始7。

如果你2345都skip，那么一般我就希望你bug free。
否则你没办法和其他候选者做比较，往往bugfree又要求你code组织很好，否则谁都很难一眼看出你有没有问题。

### 7. followup
还有什么能改进的吗？
这是考察面试者的知识面，也看你是不是耐心，
很多时候，很多面试者做出题目高兴的得意忘形，到这里就开始语无伦次的乱说。
这不会影响到是不是hire，但是可能会影响是不是strong hire，也可能影响到你的level。

举例子：
我觉得还需要写点
- javadoc啊
- unit test
- regression test
- performance tuning
- bench marking
- A/Btesting
- 等等

## 总结
如果你能想到1-7中的所有点，谁会在乎你是不是刷过这个题目？
即使你刷过这个题目，我也十分确定你刷的比别人好很多。你就是我心中想要的那个同事。
反之如果你只做到了6#，但是别人做了1234567，那你又怎么能面试成功呢？

https://www.1point3acres.com/bbs/thread-433722-1-1.html


在上一篇帖子中提到了coding的一般步骤与考察点, 在开贴讨论design behavior culture fit前，继续深入的讨论一下coding的考察范围，也以此做为对一些同学，特别是newgrad的问题的统一回复。
我就不排版和检查拼写了，大家继续凑合读。

## coding种类与应对策略
大致上，面试官在开始面试前，会收到一封email，里面回
- 大致说明每个人需要侧重于考察面试者的哪个方面
- 对于coding来说，一般有三类问题，每个面试官会被分配到一类问题

### 1. solid coding
这类问题说白了谁都知道怎么做, 纯粹就是考察
- coding是不是扎实,
- 平时自己写code多不多,
- 能不能快速的把自己的idea转化为code

对于面试者来说属于必考种类.
newgrad一般会有两轮甚至三轮这样的题目.
有很多工作经验的人可能就只有1轮了.

这类题目不过关, 很可能电面死掉或者前几轮突然死亡.

solid coding又一般可以分成两个小类：
### 1.1 考察你对算法的基本理解，以及边界条件的运用
比如findkthlargestintegersearchinrotatearraybitmanipulation等等

### 1.2 考察你对基本数据结构，以及复杂度的理解
比如
- binary search tree
- linked list vs array
- stack
- tree dfs
- tree bfs
- 等等

按难度来分
- easy的, 比如
	- 3sum
	- tree level order iterator
- medium难度的,比如
	- reverse linked list from index m to index n 
	- course schedule
	- string multiplication
- hard难度的,比如
	- valid number 
	- 复杂的 calculator等

## 应对策略

### 1.1 类型
如果是简单和medium的, 没得说了, 就是希望你又快又好.
除了勤奋和熟练, 没有什么好策略.

对于像merge sort, partition这类的算法, 如果7-8分钟还写不出bugfree.
我估计就没戏了.
easy问题请多多注意
- 边界条件
- int溢出
- null pointer
- 负数
- 非法输入等

hard1.1 的请参考1.3

### 1. 2类型
简单和medium, 请在写代码前多阐明复杂度,
这类数据结构的问题, 往往也可以在coding前画图来表示运行状态.
图画的清楚,也是个重要的加分项.

hard请参考13

### 1.3 hard类型的coding题目

这往往是考察你的solid coding的能力。
即我在前文中提到的，你做事的方式和你思考问题的方法。
即给你一个coding任务，你如何从白板开始，一步步的做出bug free的程序。
这类问题的过程重于结果。

比如 valid number，你能确保每实现一个模块，都没有regression，都没有bug，比你一下子实现所有的feature，但是有很多bug要好很多。

一般来说面试官看你
- 是否能够，一步步的分隔出小的coding模块（method），
- 你如何设计test case，
- 你如何能够确保这些test case 能cover所有的scenario
- 你是不是和面试官提前做了足够的沟通，并且限定了coding范围

从这个角度来说valid number，其实是个很不错的solid coding面试题。
限于篇幅我就不展开来说了

## 2. problemre solving
这类问题对于newgrad是关键, 也是能帮你differentiate的关键。
说白了，计算机并不是只有算法。
我们还需要数据库，操作系统，网络安全等方面的知识。
newgrad这些方面要弱一些所以面试者希望newgrad能展现出思维敏捷多思考快速反应的能力。

problemre solving 就为了考察这个能力而诞生的。

problemre solving也可以分成四个小类型

### 2.1 API design
这类问题是为了更深入的考察你对数据结构的理解与运用. 例如
- LRU cache
- insert 
- delete 
- get Random
- ALLO(1)
- design twitter等等

### 2.2 Abstraction 抽象
这类问题是考察你能不能把一个相对抽象的问题, 规约到你熟悉的问题上面. 

比如
- sky line problem
- int stream find median
- cleaning robot
- 等等

###  2.3 计算机小程序
例如
- thread pool
- 爬虫
- 日志merge等
- random generator等

### 2.4 dynamic programming问题

这类问题有点像solid problem resolving，主要考察你是不是有systemmatic的方法，来降低一个bruteforce程序的复杂度，这类问题一般都不是很easy的问题。

根据面试官心情, 可能走的很深，很难，也可能最后演变成barraiser

## 应对策略

### 2.1 主要考察你对数据结构的深层次认识。
首先请同时确保你理解了题目的意思
最好能问清点条件，例如immu table array max subarray sum那数组将来会变吗？

问清这类的问题，有助于你写代码前做好重构和测试的准备。

其次如果你能证明你选择的算法的复杂度，甚至证明这就是最佳复杂度，那是一个大大的加分项。
如果不能，至少你也问问面试官，是不是已经满意了，再开始写代码。

### 2。2 这个我自己也头疼
说实话，如果第一次遇见了skyline，我也不知道能不能搞定。
大家有好办法请回复
有什么好办法能系统化的解决这类的问题，我个人觉得很多时候靠灵光一闪。

### 2.3 这类问题
主要看你平时积累，也是一大类不能通过leetcode练习的问题。
临时抱佛脚的话，我个人推荐java concurrencyin practice这本书。

### 2.4 动态规划
我不知道为什么很多人害怕动态规划。
面试中的动态规划大致分为
- 单向递归（首或者尾）
- O（n2）或者O(n3)
- 距离递归O(mn)递归
- 有限定条件的NP(背包）

每种类型，听几节课，懂了基本原理，即可。
至于贪心和带状态的dp(走道铺砖）一类的dp，至少我没在面试中遇到过。
因为很难临时造出一道这样的题目，面试官一般也没这个能力和时间来思考题目是不是严谨。

贪心准备下
- 加油站
- 迪杰斯特拉
- 最小生成树
就足够了

## 3. barraiser
这类的问题，只有当on site应聘者的数量远远大于head count的时候，或者你前几轮明显超出了电面时对你的定位才会发生。
其目的是帮助公司选择最优秀的人。
对应聘者来说坏消息是要度过痛苦一小时，好消息是你能充分了解这公司厉害的人有多厉害，能充分展示你的能力，甚至被越级录取也不是不可能。

barraiser也是三小类


