## 算法描述

如果有限状态机、迭代函数或者链表存在环，那么一定存在一个起点可以到达某个环的某处(这个起点也可以在某个环上)。

初始状态下，假设已知某个起点[节点](https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9 "节点")为节点S。现设两个指针t和h，将它们均指向S。

接着，同时让t和h往前推进，但是二者的速度不同：
- t每前进1步，
- h前进2步。

只要二者都可以前进而且没有相遇，就如此保持二者的推进。
- 当h无法前进，即到达某个没有后继的节点时，就可以确定从_S_出发不会遇到环。
- 反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环，设其为环C。

如果确定了存在某个环，就可以求此环的起点与长度。

上述算法刚判断出存在环C时，显然t和h位于同一节点，设其为**节点M**。

- 求解环C的长度
	显然，仅需令h不动，而t不断推进，最终又会返回节点M，
	统计这一次t推进的步数，显然这就是环C的长度。

- 求出环C的起点
	只要令h仍均位于节点M，而令t返回起点节点S，
	**此时h与t之间距为环C长度的整数倍**。
	
	随后，同时让t和h往前推进，且保持二者的速度相同：
	t每前进1步，h前进1步。
	
	持续该过程直至t与h再一次相遇，
	设此次相遇时位于同一节点P，
	则节点P即为从节点S出发所到达的环C的第一个节点，
	即环C的一个起点。

## 资料
- [wikipedia](https://zh.wikipedia.org/zh-hans/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95)