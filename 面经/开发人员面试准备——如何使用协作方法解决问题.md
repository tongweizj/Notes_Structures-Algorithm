https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/

无论您是多么有经验的开发人员，接受一份新工作的面试总是有压力的。根据我自己的经验，这当然是正确的。

就我而言，我已经作为软件开发人员专业工作了两年半，而且我已经不得不面对开发人员面试五次了。

我见过人们过于专注于学习特定的算法问题，或者在专门针对面试挑战的在线平台上进行培训。但我认为采访还有另一面同样重要——人们不太关注它。

所以，如果你想知道我认为你应该如何集中精力进行面试培训，那就喝杯咖啡，放松一下。

这将是一段旅程（但不要担心——包括 Python 示例！）。

## 以下是我们将介绍的内容：

1.  [算法和数据结构对面试重要吗？](https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/#do-algorithms-and-data-structures-matter-for-interviews)
2.  [专注于协作方法](https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/#focus-on-a-collaborative-approach)
3.  [尝试进行模拟面试](https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/#try-doing-a-mock-interview)  
    –[最初的示例面试问题](https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/#the-initial-example-interview-problem)  
    –[第二个示例面试问题](https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/#the-second-example-interview-problem)  
    –[最难的示例面试问题](https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/#the-hardest-example-interview-problem)
4.  [最后的话](https://www.freecodecamp.org/news/collaborative-problem-solving-with-python/#final-words)

让我们开始吧。

## **算法和数据结构对面试重要吗？**

简短的回答是**肯定的**。

了解数据结构和算法通常会帮助您找到工作。此外，拥有扎实的算法背景的好处包括在面临具有挑战性的问题时能够做出更好的决策。

在现实生活中，算法问题不会像您可能学习的学术练习中的陈述那样出现。尽管如此，您受过的训练越多，您就越有可能识别出伪装的平衡二叉树或最短路径算法的应用。

考虑到这一点，我建议不要仅仅为了你想擅长的面试而训练数据结构和算法。算法的设计以及如何使用正确的数据结构是非常漂亮的主题，可以仅仅为了知识的乐趣而进行研究。

面试的范围非常有限。相反，专注于问题的解决问题部分。尝试了解如何将算法（或其变体）用于类似任务。研究所有变体，并学会在不同情况下识别它们。这将帮助你以开放的心态面对新的任务。

另外，不要记住解决方案。它不会带你去任何地方。如果您只针对非常具体的主题进行培训，那么经验丰富的开发人员很容易提出正确的问题，让您展示自己。

解决一个问题并尝试使用不同的方法来解决它。每次都尝试解决更难的问题。走出你的舒适区。

它会得到回报。

## **专注于协作方法**

[大多数人在Leetcode](https://leetcode.com/)等网站上进行面试培训。这没有问题。这些网站非常适合训练您解决问题的能力。

至少在过去的八年里，我一直在参加竞争性编程竞赛，而且我一直从这些在线资源中受益。

但是对于大多数想要在面试中表现出色的软件工程师来说，有一件事是难以理解的。他们没有针对软件开发最重要的方面进行培训：**协作**。

通常，当您在在线平台上遇到问题时，它会对某些输入的最大值进行一些限制。它还可能有一些时间和内存限制，需要您调整解决方案以提高或降低效率。但这不是现实生活中的样子。

如何将这些约束映射到现实生活场景并不明显。它们通常以来自客户的非常具体的请求或团队非常具体的特征的形式出现。

在实际项目中，团队将**协作**确定这些约束是什么。您必须分析您的用例、完成任务的时间、最终用户是谁、将有多少人参与其中，等等……

经过一系列的讨论，您将达成共识，并最终开始实施适合您需求的解决方案。而且这个解决方案在某些情况下甚至不必更高效，但例如实施起来最快。

这也是面试官希望在面试中从候选人身上看到的。

你不会直接跳到实施你所知道的解决你所面临问题的最佳解决方案。相反，您应该将面试官视为宝贵的资源，将他们视为您的队友（最终，您希望他们成为）。询问有关团队如何偏爱要实施的问题的解决方案的问题。

这将导致非常富有成果的讨论，您可以在其中展示您的编码能力和协作技能。您可以开始提出简单的解决方案，并引导您的面试官了解如何使用最好的 Aces 改进解决方案的过程。

作为在线培训的最后一点，我建议进行个人和团队培训。使用诸如[Codeforces](https://codeforces.com/)或[AtCoder](https://atcoder.jp/)之类的网站，它们有大量有趣（且具有挑战性）的问题，并尝试每天与自己竞争。

不要专注于您的评分。我以前做过，它只会让你退缩。

## **尝试进行模拟面试**

如果您在文章中达到了这一点，我想建议您进行一些练习。让我们进行一次模拟面试，我将担任面试官。我会告诉你我认为候选人（你）应该如何回答每一个问题并完成每一项任务。

当然，我们将只关注编程挑战部分。访谈的其他方面，例如谈论以前的经历，也很重要，但我们会尽量在另一篇文章中介绍。

所以，如果你觉得准备好了，那就出发吧！

### 初始示例面试问题

让我们从您将要解决的任务开始。请记住，如果你和我曾经遇到过这种情况，我不会使用相同的示例，但当然，我将使用相同的方法 😉。

问题陈述如下：

> “给定一个整数`X`，判断它是否是质数。”

您可能会想要寻找您所知道的最佳解决方案来解决此问题。正如我之前解释的那样，我认为这种方法并不总是正确的。

相反，我想知道的是解决这个问题的不同方法。另外，想请教一下这个任务的要求。就像是：

-   我们应该以性能为目标还是更快地解决问题？
-   我们是否应该为其他开发人员制定一个易于理解的解决方案？

通常，在为问题创建第一个解决方案时需要考虑的一些方面是：

-   Easy vs Hard：我们应该制定一个易于实施的解决方案，即使它并不完美，还是应该寻求一个更强大但难以实施的解决方案？
-   朴素与高效：我们应该先提供一个可行的、朴素的解决方案，然后再提供一个更高效的解决方案，还是我们应该直接转向高效？

评估您的团队想要优化的内容。达成共识，并实施商定的解决方案。

就我而言，如果您提出您能想到的最简单、实施最快、正确的解决方案，然后指导我完成如何改进该解决方案的过程，我会很高兴。

这个问题的一个很好的初始解决方案的例子如下：

```python
# naive.py

def is_prime(x: int) -> bool:
    if x in [0, 1]:
        return False
    for i in range(2, x):
        if x % i == 0:
            return False
    return True
```

如您所见，这个函数是正确的。由于质数是一个只能被该数和它本身整除的整数，因此从 迭代到寻找 的除数`1`是有意义的。如果我们找到一个，我们可以立即返回。否则，我们返回。作为边缘情况，数字和不是定义上的素数。`2``x - 1``x``False``True``0``1`

这是一个很好的起点！

现在，在深入优化此方法之前，您可以讨论一下代码的风格。它足够 Pythonic 了吗？我们关心它吗？它可读吗？

所有这些问题乍一看似乎并不重要，但由于我们是一个团队，所以它们确实很重要。拥有一种编码风格很重要，因为它使每个团队成员更容易理解彼此的代码，并且会加快审查和重构的速度。此外，代码被阅读的次数多于编写的次数，因此可读性很重要！

您可能会想炫耀一下您的 Python 技能并重写之前的函数，如下所示：

```python
# pythonic_naive.py

def is_prime(x: int) -> bool:
    return False if x in {0, 1} else all(x % i != 0 for i in range(2, x))
```

我认为这是编写此函数的一种很好的 pythonic 方式。但是，由于团队是这里最重要的事情，因此应该讨论这一变化。

可能有些团队成员对 Python 不是很熟练。也许，在这种情况下，我们应该优化可读性，并保持我们最初编写的功能。

在进入性能之前，一个更有趣的添加是向函数添加文档字符串。正如我之前所说，这段代码最有可能在未来被你的团队成员阅读。那么，重要的是让他们（以及你未来的自己）更容易理解这个功能在做什么。

也许将函数更改为以下内容会增加更多价值：

```python
# naive.py

def is_prime(x: int) -> bool:
    """This function takes an integer `x` as
    argument and checks whether is prime or not.

    Args:
        x (int): The integer number to test for primality.

    Returns:
        bool: True if the number `x` is prime, False otherwise.
    """
    if x in [0, 1]:
        return False
    for i in range(2, x):
        if x % i == 0:
            return False
    return True
```

#### 第一次优化

到目前为止，我们有一个可行的初始解决方案。我们讨论了重要的主题，例如代码样式、可读性和开发人员文档。这些都是团队合作时需要考虑的重要事项。

但是我们还没有谈到解决方案的性能！所以，现在可能是时候了。

这时，您可能应该提出可以实现此功能，以便运行得更快。现在是展示你内心所有算法知识的时候了。

前面的解决方案的时间复杂度为`O(x)`，其中`x`是函数作为参数的输入整数。这可以`O(sqrt(x))`使用以下代码进行优化：

```python
# sqrt.py

import math

def is_prime(x: int) -> bool:
    if x in [0, 1]:
        return False
    for i in range(2, int(math.sqrt(x)) + 1):
        if x % i == 0:
            return False
    return True
```

或者甚至像这样，不导入`math`库：

```python
# sqrt.py

def is_prime(x: int) -> bool:
    if x in [0, 1]:
        return False
    i = 2
    while i**2 <= x:
        if x % i == 0:
            return False
        i += 1
    return True
```

我可以接受任何一种选择。

为了使实际的代码更改更清晰，我在之前的实现中省略了文档字符串。但是，最好在开发人员的文档中包含函数的时间复杂度。您可以提供的有关代码的信息越多，对您的团队成员和您自己就越好。

到目前为止你做得很好。让我们继续！

### 第二个例子面试问题

到目前为止，我已经能够评估您是否具备与团队一起完成简单任务所需的协作技能。现在是时候让事情复杂化了。

这是我提出的第二个问题的陈述：

> “给定两个整数`L`和`R`，计算区间中有多少个素数`[L, R]`。”

再一次，我会建议讨论团队为此任务设定的优先级。从简单开始，逐步完成改进初始解决方案的过程。强调过早优化不是一个好的做法。

此外，讨论使用您为上一个任务实施的解决方案来解决这个问题的可能性。这是有道理的，如果我们有一个函数来判断一个整数是否是素数，我们就可以将它用于一个范围内的每个数字。

这是您在现实生活中必须要做的事情。通常，当出现新任务时，团队应该查看维护的项目，看看哪些可以重用以加快实施过程。如果不这样做，您可能最终会编写重复的功能。

话虽这么说，这个任务的一个好的初始解决方案可能是这样的：

```python
# range_primes.py

from sqrt import is_prime

def count_primes(l: int, r: int) -> int:
    primes = 0
    for i in range(l, r + 1):
        if is_prime(i):
            primes += 1
    return primes
```

这非常好，并且您已经证明可以重用以前的功能来构建新功能。与第一个示例一样，您可能会想要炫耀您的 Python 技能并像这样编写此函数：

```python
# range_primes.py

from sqrt import is_prime

def count_primes(l: int, r: int) -> int:
    return sum(bool(is_prime(i)) for i in range(l, r + 1))
```

我建议不要将此 Pythonic 实现作为您的第一选择。留待讨论，评估代码的可读性，也许还能分析性能上的差异。不要忘记文档字符串！

下一节是事情变得有趣的时候。继续阅读。我们在最后一步...

### 最难的例子面试问题

还记得我之前说过竞争性编程网站中存在的限制很难映射到现实生活中的需求吗？

以下是我将如何向您提出一项艰巨的挑战，以确定这些限制并实施您可以实施的最佳解决方案：

> “假设客户希望我们提供计算范围内素数的功能作为一项服务。他们希望将重点放在性能上，因为他们计划经常使用此服务。您将如何实现它？”

如果您一直在为面试练习算法技能，您可能已经解决过几次与此类似的问题。这里的主要区别是上下文的变化。

我没有给你精确的说明、数字限制和输入或输出格式，而是给你一个更广泛的任务描述。我在这里的目标和以前一样：让你和我互动，就好像我们是队友一样，从我们所知道的少量信息中找出解决这个问题的方法。

希望在交换了几个问题和答案之后，我们可以将之前更加模棱两可的陈述翻译成更熟悉的东西：

> “给定一组形式为`[L, R]`, answer 的查询，对于每个查询，该范围内有多少整数是素数。”

这是有道理的，因为客户希望经常使用此服务，如描述中所述。

我们想专注于性能。在实施解决方案时，这应该是我们主要关注的问题。但是，获得最佳解决方案的最佳方法仍然是从一个简单的开始，分析我们是否满足我们的性能要求，并逐步改进。让我们看看整个例子。

我们可以从使用我们在上一步中实施的解决方案开始。够好了吗？

假设我们将作为函数参数的数字的最大范围是`[1, 10^6]`。此外，实际上，我们假设我们的服务每分钟将回答的查询数量约为`10^5`.

我们之前的解决方案的时间复杂度`O(sqrt(n))`为确定一个数是否为素数。如果我们对范围内的每个数字都这样做，复杂度会上升到`O(n * sqrt(n))`. 最重要的是，如果我们对每个查询都这样做，我们最终会得到更高的时间复杂度`O(q * n * sqrt(n))`。

将之前的变量替换为它们可能具有的最高可能值，您会发现此解决方案将采用`10^14`操作来回答所有查询。假设一台计算机`10^8`每秒可以执行大约基本操作，那么`10^6`完成所有这些操作大约需要几秒钟。

> 注意：将 10^6 秒转换为天。你会惊讶🤯。

如果目标是优先考虑我们解决方案的性能，则此解决方案是不可行的。让我们看看如何改进它。

在这一点上，我希望你能拿出你在所有这些在线平台上接受过的最好的培训，并向我展示一个令人印象深刻的解决方案。现在是展示您所有分析和算法技能的时候了。

但只是现在，因为我知道你是一个团队合作者。

#### 最终的解决方案

由于这是一次模拟面试，我很想知道您有效解决最后一个问题的方法。让我知道您将如何实施解决方案或在 GitHub 上分享您的代码——不要害羞。

我向你保证一件事：如果你能在真正的面试中做到这一点，即使你不知道这个问题的最佳解决方案，可能也没什么大不了的。这并不意味着您不应该尽力解决它，但请放心，您已经做得很好了。

就是这样！现在我想看看你的代码。

## **最后的话**

在这篇文章中，我试图总结一些我认为在编程面试中最重要的方面。我特别强调协作部分，因为我认为大多数人都低估了这项技能的重要性。这是必须的，特别是如果您想与其他开发人员一起工作。

我试图通过模拟面试来引导您，在模拟面试中我解释了在面试中面对标准编码任务时我会遵循的思维过程。我希望这个练习有用，并且它可以在你的下一次面试中帮助你（作为候选人或面试官）。

分享您对这次模拟面试的看法，让我们开始富有成果的讨论。