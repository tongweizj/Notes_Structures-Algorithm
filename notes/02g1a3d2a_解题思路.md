## 基本思路

1. 理解 -- > 原来非线性复杂问题
2. 升华 --> 抽象+分解为相对简单的**子问题**
3. 生产 --> 解出子问题
4. 收尾 --> 再合并子问题的解，得出原问题的解。

通常子问题非常相似
动态规划算法试图只解决一次子问题，则将其记忆化存储
以便下次需要同一个子问题解之时直接查表。 

这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 

## 子问题

### 1.  划分
按照问题的特征，把问题分为若干阶段。
注意：划分后的阶段一定是**有序的或者可排序**的  

### 2.  最优子结构
什么时候可以称一个问题具有最优子结构性质，有两个条件
- 如果问题有最优解
- 并且它所包含的子问题的解，也是最优的。

在用动态规划算法解决问题时，最优子结构能提供重要线索。
这一点有点像贪心算法。
每一步都是最优解，并且每一步都是相同的解。

### 3.  重叠⼦问题
子问题重叠是指
在用递归算法自顶向下对问题进行求解时，每次产生的子问题，可能是之前已经解决过的。
也就是说有些子问题，会被重复计算多次。

动态规划算法正是利用了这种子问题重叠的特性，对每一个子问题只计算一次，并将结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。  

## 状态
思维框架：
    明确 base case -> 明确「**状态**」-> 明确「**决策**」 -> 定义 dp 数组/函数的含义。

1. 状态，两个子问题之间的跳跃，就是状态转移
2. 状态转移
3. 状态转移方程

### 1.  确定状态和状态变量
将问题发展到各个阶段时, 所处的各种不同的客观情况表现出来
状态的选择要满足**无后续性** 

### 2.  确定决策并写出状态转移方程
根据相邻两个阶段状态之间的联系，来确定**决策方法**和**状态转移方程**  

根据上一阶段的**决策**和**状态**来导出本阶段的状态。

推导的过程，用数学方式表达，就是状态转移⽅程
比如
斐波那契数列的方程 **Fn= Fn-1+Fn-2**

### 3. 边界条件
状态转移方程是一个递推式，因此需要找到递推终止的条件  
 
**即：**

【初始状态】→【决策1】→【决策2】→…→【决策n】→【结束状态】

_注意：_
1.  问题阶段
2.  每个阶段的状态
3.  相邻两个阶段之间的递归关系

### 4.  无后效性
即某阶段状态一旦确定，就不受这个状态以后决策的影响。
也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。  
斐波那契数列的方程 Fn= Fn-1+Fn-2
Fn 不会影响 Fn-2
Fn-2会影响 Fn，这样的影响是单向传导
   

