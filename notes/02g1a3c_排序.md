

https://visualgo.net/zh/sorting

## 1. 冒泡与选择排序

o(n^2)

### [[02g1a3c1_冒泡排序|冒泡排序]]
通过交换相邻两个元素，将最大元素升至最后位置（像水中的冒泡）

### [[02g1a3c3_ 选择排序|选择排序]]
遍历所有元素，选择最小元素，与未排好序的元素的一个元素进行交换。以此遍历n趟，最终达到所有元素有序。

### 适用场景
相对其他排序算法，除了**实现简单、容易理解外**，并没有任何优势。
所以在**实际开发中，不推荐这两种排序算法**

## 2. [[02g1a3c2_ 插入排序|插入排序]]

非常简单的排序
每次将某个元素插入到合适的位置，而该元素之后的所有元素都需要往后挪一个位置。在生活中玩扑克牌时，想要对扑克牌进行排序，我们通常使用的也是「插入」排序，比如大王，就插入到最前面。

### 适用场景
大部分数据距离它正确的位置很近，近乎有序。

如原始数据根据订单完成时间排序，现在需要根据订单发起时间排序。
这样，每个元素就能很快挪到正确位置，所以在这种场景中，其效率远高于其他元素。

## [[02g1a3h4_ 希尔排序|希尔排序]]

o(nlogn)

## [[02g1a3c5_归并排序|归并排序]]

## 3. [[02g1a3c6_快速排序|快速排序]]
“快速排序是最快的通用排序算法”——《算法 第4版》

**适用场景**
在大多数实际情况中，都适合使用快速排序。
但它不是稳定的排序算法，稳定是指：两个相等元素，排序前先后顺序与排序后先后顺序一致。比如元素a和元素b相等,排序前a在b前面，若排序后，a也b在前面，则说明其排序算法是稳定的。


- 堆排序

o(n)
- 计数排序
- 基数排序
- 桶排序
