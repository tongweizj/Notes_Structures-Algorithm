## 概念

双指针，指的是在遍历对象的过程中，两个指针指向不同的元素，从而协同完成任务。
也可以延伸到
- 多个数组的多个指针

- 两个相同方向（_快慢指针_）

### 滑动窗口
若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口
两个指针包围的区域即为当前的窗口
经常用于区间搜索。


### 对撞指针
若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索.
待搜索的数组往往是排好序的。


换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。

### 使用场景

1.**在数组或者字符串中，找两个或者两个以上的数字**  

例如：找到三数之和或者两数之和为0的组成。 
单指针处理，则需要嵌套循环，一个循环遍历找一个数，另一个循环遍历找另一个数。 
双指针处理，需要先进行排序预处理，然后只需要采用头尾指针，执行一次遍历，直到头尾指针相重合，时间复杂度为O(n)，但是整体时间复杂度主要取决于排序算法，通常为 O(nlogn)。
```
while r >l
	if nums[l] + nums[r] >0
	   r --
	if nums[l]+ nums[r] <0
	   l ++
	if nums[l]+ nums[r] = 0
	   zero.push([l,r]) // 保存等于0 两个数的位置   
	   
```

**2.对于数组或者字符串的反转**  

**如果是单指针的话**，需要在遍历的时候，将每个元素unshift进入数组中，遍历完之后缓存的数组就是结果，原来遍历的数组不需要了，这就增加了额外的O(n)的内存，空间复杂度为O(n)。  

**如果是双指针的话**，那么对于数组的反转，可以通过头尾指针，加上一个变量缓存达到反转的效果，空间复杂度为O(1)。

总的来说，什么时候我们需要考虑双指针？主要包含两类问题：  
1. 循环嵌套转为单循环问题，优化时间复杂度  
2. 通过指针记录状态，优化空间复杂度

  



## 对撞指针

### 概念
对撞指针是指在数组中，指定两个指针
- 指向最左侧的索引定义为 `左指针(left)`，
- 最右侧的定义为 `右指针(right)`，
然后从两头向中间进行数组遍历。

> 对撞数组适用于连续数组和字符串，也就是说当你遇到题目给定连续数组和字符床时，应该第一时间想到用对撞指针解题。


### 伪代码

```
public void find (int[] list) {
  var left = 0;
  var right = list.length - 1;

  //遍历数组
  while (left <= right) {
    left++;
    // 一些条件判断 和处理
    ... ...
    right--;
  }
}
```

### 使用场景



### 算法实例

原题: [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)
 编写一个函数，其作用是将输入的字符串反转过来。
 输入字符串以字符数组 char[] 的形式给出。
 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

**示例 1：**
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

**示例 2：**
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

解答

可以套用前面的伪代码：

```
class Solution {
    public void reverseString(char[] s) {
        // 异常处理 
        if (s.length == 0 || s.length == 1) return ;
        // 正常逻辑
        int left = 0;
        int right = s.length-1;
        while (left <right) {
            char temp = s[left];
            s[left++] = s[right];
            s[right--] = temp;
        }
        return ;
    }
}
```

