## 1. 关键词

- **最短路径**



## 知识点

- 广度优先搜索（breadth-first search，BFS）
- BFS 算法起源于⼆叉树的层序遍历，其核⼼是利⽤队列这种数据结构（先入先出）进行遍历。

且 BFS 算法常⻅于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达⽬标时的代价是最⼩的。如**最短路径等问题**

### 1. 广度优先搜索

#### 最短路径

最短路径问题 shorterst-path problem



#### 广度优先搜索

你能够找出两样东西之间的最短距离

解决的问题：

1. 从点A出发，有前往点B的路径吗 
2. 从点A出发，前往点B的哪条路径最短 



##### 搜索算法说明

1. 找出所有1度的点，加入队列

2. 从队列中取出点，来查看是否满足要求
   1. 不满足就把点相关的点，再加到队列中。
   2. 满足，就记录下来

3. 回到第二步
4. 



#### 对列queue

先进先出，后进后出



#### 搜索算法实现

```python
from collections import deque

// 所有相连关系
graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

// 条件
def person_is_seller(name):
  return name[-1]=='m'

// 循环
def search(name):
  search_queue = deque() // 创建队列
  search_queue += graph[name]
  searched = []
  while search_queue:
    person = search_queue.popleft()
    if person not in searched:
      print person + "is a mango seller!"
      return True
    else:
      search_queue += graph[person]
      searched.append(person)
  retrun False
  
search("you")
```



#### 行时时间 



常写作O (V + E ) 

- V 为顶点（vertice）数 

- E 为边数。







## 二分搜索

```js
function BinarySearch1 (arr, target) {
    return search(arr, target, 0, arr.length - 1)
    function search (arr, target, from, to) {
        if (from > to) {
            return -1
        }
        const mid = Math.floor((from + to)/2)
        if (arr[mid] > target) {
            return search(arr, target, from, mid - 1)
        } else if (arr[mid] < target) {
            return search(arr, target, mid + 1, to)
        } else {
            return mid
        }
    }
}

function BinarySearch2 (arr, target) {
    let from = 0
    let to = arr.length - 1
    let mid = Math.floor((from + to)/2)
    while (from <= to) {
        mid = Math.floor((from + to)/2)
        if (arr[mid] > target) {
            to = mid - 1
        } else if (arr[mid] < target) {
            from = mid + 1
        } else {
            return mid
        }
    }

    return -1
}
```









## 算法特点

BFS 相对 DFS 的最主要的区别是：
- BFS 找到的路径⼀定是最短的
- 但代价就是空间复杂度可能⽐ DFS ⼤很多

## 使用场景

场景 1

将问题抽象成「图」
在其中找出起点start 到终点 target 的最近距离

## 解题框架

```c++
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
  Queue<Node> q; // 核⼼数据结构
  Set<Node> visited; // 避免⾛回头路

  q.offer(start); // 将起点加⼊队列
  visited.add(start);
  int step = 0; // 记录扩散的步数

  while (q not empty) {
    int sz = q.size();
     /* 将当前队列中的所有节点向四周扩散 */
    for (int i = 0; i < sz; i++) {
      Node cur = q.poll();
      /* 划重点：这⾥判断是否到达终点 */
      if (cur is target)
        return step;
       /* 将 cur 的相邻节点加⼊队列 */
       for (Node x : cur.adj()) {
         if (x not in visited) {
           q.offer(x);
           visited.add(x);
         }
        }
     }

     /* 划重点：更新步数在这⾥ */
     step++;
   }
}
```

[111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    // 异常
    if(!root) return 0;
    if(!root.left && !root.right) return 1;
    // BFS start
    let depth = 1;
    let queue = [root]; // 将整个TreeNode对象，作为第一个元素，填入 q
    while(queue.length > 0 ){
      for(let i = 0; i < queue.length; i++){
        let node = queue.shift();
        // 判断是否叶子节点
        // 如果 y，返回结果，这个叶子节点是最短路径
        if(!node.left && !node.right) return depth; 

        // 拆 Tree，填入 q
        else{
          if(node.left) queue.push(node.left);
          if(node.right) queue.push(node.right);
        }
      }

      depth++;
    }

    return depth; // 这里返回的叶子，是没有最短的情况，给出最长
};
```

**注意**
这个 while 循环和 for 循环的配合，
while 循环控制⼀层⼀层往下⾛，
for 循环利⽤ sz 变量控制从左到右遍历每⼀层⼆叉树节点：