
## 斐波那契数列

### 数列描述
#### 从数学上
**斐波那契数**是以递归的方法来定义：
-   F0=0
-   F1=1
-   Fn=Fn−1+Fn−2 (n>=2)

#### 从文字上
斐波那契数列由0和1开始，
之后的斐波那契数就是由之前的两数相加而得出。

首几个斐波那契数是：
1，1, 2，3，4，5，8，13，21，34，55，89

**特别指出**：0不是第一项，而是第零项。

### 代码实现
全代码可见‘./code/fibonacci.js’
v1：原始递归
```js
function fib(N) {
  if (N == 1 || N == 2) return 1;
  return fib(N - 1) + fib(N - 2);
}
```

v2: 增加备忘录递归
```js
function fib2(N) {
  // 备忘录全初始化为 0
  let memo = new Array(N + 1).fill(0);
  // 进⾏带备忘录的递归
  return helper(memo, N);
}

function helper(memo, n) {
  // base case
  if (n == 0 || n == 1) return n;
  // 已经计算过，不⽤再计算了
  if (memo[n] != 0) return memo[n];
  memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
  return memo[n];
}
```

v1 在我的电脑上是跑不出 n=100 的情况的
v2 可以跑出
这其中的差别就是，v2 减少了大量的重叠子问题
看下图
![[Pasted image 20230411163529.png]]

v3: 动态规划：dp 数组的迭代（递推）解法



## change cions
### 1. 思维方式
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

#### 1、确定 base case
⽬标⾦额 amount 为 0 时算法返回 0

#### 2、确定「状态」
也就是原问题和⼦问题中会变化的变量。
由于硬币数量⽆限，硬币的⾯额也是题⽬给定的，
只有⽬标⾦额会不断地向 base case 靠近，所以唯⼀的「状态」就是⽬标⾦额 amount。

#### 3、确定「选择」
也就是导致「状态」产⽣变化的⾏为。
⽬标⾦额为什么变化呢，因为你在选择硬币，你每选择⼀枚硬币，就相当于减少了⽬标⾦额。
所以说所有硬币的⾯值，就是你的「选择」。

#### 4、明确 dp 函数/数组的定义
我们这⾥讲的是⾃顶向下的解法，所以会有⼀个递归的 dp 函数，⼀般来说函数的参数就是状态转移中会变化的量，也就是上⾯说到的「状态」；函数的返回值就是题⽬要求我们计算的量。

就本题来说，状态只有⼀个，即「⽬标⾦额」，题⽬要求我们计算凑出⽬标⾦额所需的最少硬币数量。

所以我们可以这样定义 dp 函数：dp(n) 表示，输⼊⼀个⽬标⾦额 n，返回凑出⽬标⾦额 n 所需的最少硬币数量。