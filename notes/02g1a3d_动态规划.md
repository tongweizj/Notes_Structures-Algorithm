## 算法定义

动态规划(dynamic programming)是运筹学的一个分支，是用来解决‘决策过程(decision process)最优化’的数学方法。

20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。

1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。


*个人理解*
动态规划，两个字怎么解释。
1. 动态
是指，要解决的问题是动态的。不是线性的问题。
比如斐波那契数列，它就不是线性增长的数列。

2. 规划
或者应该看 programming 这个单词，
谷歌翻译有两个解释：
- the process or activity of writing computer programs. 
	编写电脑程序的过程或者活动
	programming languages
- the action or process of scheduling something, especially radio or television programs.
	计划、规划一件事情的过程或者活动，特别是广播电视节目
	the programming of shows  这个 show 的计划过程
显然是第二个意思。

所以合起来，DP 是对一个动态事件的全程规划

### 算法描述

核⼼思想是穷举求最值

1. 把原来非线性复杂问题，抽象+分解为相对简单的子问题
2. 解出子问题
3. 再合并子问题的解，得出原问题的解。 

优势
- 时间复杂度 小

通常子问题非常相似
动态规划算法试图只解决一次子问题，则将其记忆化存储
以便下次需要同一个子问题解之时直接查表。 

这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 

### 常见问题

求最值：
- 求最⻓递增⼦序列
- 最⼩编辑距离

## 关键词

### 1.  最优子结构
什么时候可以称一个问题具有最优子结构性质，有两个条件
- 如果问题有最优解
- 并且它所包含的子问题的解，也是最优的。

在用动态规划算法解决问题时，最优子结构能提供重要线索。

### 2.  重叠⼦问题
子问题重叠是指
在用递归算法自顶向下对问题进行求解时，每次产生的子问题，可能是之前已经解决过的。
也就是说有些子问题，会被重复计算多次。

动态规划算法正是利用了这种子问题重叠的特性，对每一个子问题只计算一次，并将结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。  

### 3. 状态转移⽅程
根据上一阶段的决策和状态来导出本阶段的状态。
比如
斐波那契数列的方程 Fn= Fn-1+Fn-2

### 4.  无后效性
即某阶段状态一旦确定，就不受这个状态以后决策的影响。
也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。  
斐波那契数列的方程 Fn= Fn-1+Fn-2
Fn 不会影响 Fn-2
Fn-2会影响 Fn，这样的影响是单向传导

## 解题步骤

### 1.  划分
按照问题的特征，把问题分为若干阶段。
注意：划分后的阶段一定是有序的或者可排序的  
   
### 2.  确定状态和状态变量
将问题发展到各个阶段时所处的各种不同的客观情况表现出来。
状态的选择要满足无后续性 

### 3.  确定决策并写出状态转移方程
根据相邻两个阶段状态之间的联系来确定**决策方法**和**状态转移方程**  
思维框架：
    明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

### 4. 边界条件
状态转移方程是一个递推式，因此需要找到递推终止的条件  
 
**即：**

【初始状态】→【决策1】→【决策2】→…→【决策n】→【结束状态】

_注意：_

1.  问题阶段
2.  每个阶段的状态
3.  相邻两个阶段之间的递归关系

###  5. 解题框架
根据解题思路的不同，有两个框架

⾃顶向下、递归的动态规划
```
def dp(状态1, 状态2, ...):
  for 选择 in 所有可能的选择:
    # 此时的状态已经因为做了选择⽽改变
    result = 求最值(result, dp(状态1, 状态2, ...))
  return result
```


⾃底向上迭代的动态规划
```
# 初始化 base case
dp[0][0][...] = base case

# 进⾏状态转移
for 状态1 in 状态1的所有取值：
  for 状态2 in 状态2的所有取值：
    for ...
      dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```


## 斐波那契数列

### 数列描述
#### 从数学上
**斐波那契数**是以递归的方法来定义：
-   F0=0
-   F1=1
-   Fn=Fn−1+Fn−2 (n>=2)

#### 从文字上
斐波那契数列由0和1开始，
之后的斐波那契数就是由之前的两数相加而得出。

首几个斐波那契数是：
1，1, 2，3，4，5，8，13，21，34，55，89

**特别指出**：0不是第一项，而是第零项。

### 代码实现
全代码可见‘./code/fibonacci.js’
v1：原始递归
```js
function fib(N) {
  if (N == 1 || N == 2) return 1;
  return fib(N - 1) + fib(N - 2);
}
```

v2: 增加备忘录递归
```js
function fib2(N) {
  // 备忘录全初始化为 0
  let memo = new Array(N + 1).fill(0);
  // 进⾏带备忘录的递归
  return helper(memo, N);
}

function helper(memo, n) {
  // base case
  if (n == 0 || n == 1) return n;
  // 已经计算过，不⽤再计算了
  if (memo[n] != 0) return memo[n];
  memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
  return memo[n];
}
```

v1 在我的电脑上是跑不出 n=100 的情况的
v2 可以跑出
这其中的差别就是，v2 减少了大量的重叠子问题
看下图
![[Pasted image 20230411163529.png]]

v3: 动态规划：dp 数组的迭代（递推）解法



## change cions
### 1. 思维方式
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

#### 1、确定 base case
⽬标⾦额 amount 为 0 时算法返回 0

#### 2、确定「状态」
也就是原问题和⼦问题中会变化的变量。
由于硬币数量⽆限，硬币的⾯额也是题⽬给定的，
只有⽬标⾦额会不断地向 base case 靠近，所以唯⼀的「状态」就是⽬标⾦额 amount。

#### 3、确定「选择」
也就是导致「状态」产⽣变化的⾏为。
⽬标⾦额为什么变化呢，因为你在选择硬币，你每选择⼀枚硬币，就相当于减少了⽬标⾦额。
所以说所有硬币的⾯值，就是你的「选择」。

#### 4、明确 dp 函数/数组的定义
我们这⾥讲的是⾃顶向下的解法，所以会有⼀个递归的 dp 函数，⼀般来说函数的参数就是状态转移中会变化的量，也就是上⾯说到的「状态」；函数的返回值就是题⽬要求我们计算的量。

就本题来说，状态只有⼀个，即「⽬标⾦额」，题⽬要求我们计算凑出⽬标⾦额所需的最少硬币数量。

所以我们可以这样定义 dp 函数：dp(n) 表示，输⼊⼀个⽬标⾦额 n，返回凑出⽬标⾦额 n 所需的最少硬币数量。