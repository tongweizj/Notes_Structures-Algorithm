Linked Lists
## Index
 - [ ] 介绍：
   - [ ] [单向链表（视频）](https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists)
   - [ ] [CS 61B —— 链表（一）（视频）](https://archive.org/details/ucberkeley_webcast_htzJdKoEmO0)
   - [ ] [CS 61B —— 链表（二）（视频）](https://archive.org/details/ucberkeley_webcast_-c4I3gFYe3w)
   - [ ] [[Review] Linked lists in 4 minutes (video)](https://youtu.be/F8AbOfQwl1c)
    - [ ] [C 代码（视频）](https://www.youtube.com/watch?v=QN6FPiD0Gzo) ── 并非看完整个视频，只需要看关于节点结构和内存分配那一部分即可
 - [ ] 链表 vs 数组：
        - [基本链表 Vs 数组（视频）](https://www.coursera.org/lecture/data-structures-optimizing-performance/core-linked-lists-vs-arrays-rjBs9)
        - [在现实中，链表 Vs 数组（视频）](https://www.coursera.org/lecture/data-structures-optimizing-performance/in-the-real-world-lists-vs-arrays-QUaUd)
    - [ ] [为什么你需要避免使用链表（视频）](https://www.youtube.com/watch?v=YQs6IC-vgmo)
    - [ ] 的确：你需要关于“指向指针的指针”的相关知识：（因为当你传递一个指针到一个函数时，该函数可能会改变指针所指向的地址）该页只是为了让你了解“指向指针的指针”这一概念。但我并不推荐这种链式遍历的风格。因为，这种风格的代码，其可读性和可维护性太低。
        - [指向指针的指针](https://www.eskimo.com/~scs/cclass/int/sx8.html)

 - [ ] 双向链表
   - [介绍（视频）](https://www.coursera.org/learn/data-structures/lecture/jpGKD/doubly-linked-lists)
   - 并不需要实现

## 1. 基本介绍

- 链表即链式储存结构
	在链式存储结构中除了要存储数据元素信息外
	还要存储它的后继元素的存储地址

- 它的内存分配
   - 可以是连续的也可以是不连续的，可以分配在内存未被占用的任意位置。
   - 它的内存分配不是在创建链表时一次性完成，而是每添加一次结点分配一次内存，因而没有闲置内存，所以空间效率比数组高。  

### 优点

链表的增、删、改的时间复杂度是O(1)

![数据结构与算法之美-1](http://yoese.oss-ap-northeast-1.aliyuncs.com/02g/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-5.png)

1.  插入删除效率高，时间复杂度为O(1)。
2.  不许要预先分配内存空间

### 缺点

随机访问第k个元素的时候，时间复杂度是 O(n),而数组是O(1)
存取效率低，时间复杂度为O(n)


### 链表使用场景

1.  不需要预先知道数据规模
2.  适用于插入删除操作较多，而存取操作较少的情况。

  
## 2. 链表类型

- 单链表
- 双向链表
- 循环链表
- 双向循环链表

### 单链表

![数据结构与算法之美-1](http://yoese.oss-ap-northeast-1.aliyuncs.com/02g/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-4.png)


- 每个节点，都要记录下一个节点的内存地址
- 头结点，记录链表的基地址，
- 尾节点，记录空地址NULL，表示最后



## 练习
    - [ ] 实现（我实现了使用尾指针以及没有使用尾指针这两种情况）：
        - [ ] size() —— 返回链表中数据元素的个数
        - [ ] empty() —— 若链表为空则返回一个布尔值 true
        - [ ] value_at(index) —— 返回第 n 个元素的值（从0开始计算）
        - [ ] push_front(value) —— 添加元素到链表的首部
        - [ ] pop_front() —— 删除首部元素并返回其值
        - [ ] push_back(value) —— 添加元素到链表的尾部
        - [ ] pop_back() —— 删除尾部元素并返回其值
        - [ ] front() —— 返回首部元素的值
        - [ ] back() —— 返回尾部元素的值
        - [ ] insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素
        - [ ] erase(index) —— 删除指定索引的节点
        - [ ] value_n_from_end(n) —— 返回倒数第 n 个节点的值
        - [ ] reverse() —— 逆序链表
        - [ ] remove_value(value) —— 删除链表中指定值的第一个元素
